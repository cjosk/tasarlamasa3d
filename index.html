<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Masa Konfigüratörü | Premium Tasarım</title>
    <!-- Tailwind CSS ve Inter Font Yükleniyor -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'primary-neon': '#00F0FF', // Parlak Mavi/Cyan
                        'brand-purple': '#5B21B6', // Koyu Mor
                        'brand-indigo': '#4F46E5', // Koyu İndigo
                        'dark-bg': '#111827', // Ana Arka Plan
                        'card-bg': '#1F2937', // Kontrol Kartı Arka Planı
                        'deep-card': '#374151', // Derin Kontrol Arka Planı
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <!-- Three.js ve OrbitControls Yükleniyor -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- Firebase Modülleri Yükleniyor -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, collection, query, onSnapshot, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global değişkenleri tanımlama
        window.initializeApp = initializeApp;
        window.getAuth = getAuth;
        window.signInAnonymously = signInAnonymously;
        window.signInWithCustomToken = signInWithCustomToken;
        window.onAuthStateChanged = onAuthStateChanged;
        window.getFirestore = getFirestore;
        window.doc = doc;
        window.setDoc = setDoc;
        window.getDoc = getDoc;
        window.collection = collection;
        window.query = query;
        window.onSnapshot = onSnapshot;
        window.getDocs = getDocs;
        window.setLogLevel = setLogLevel;
    </script>
    <style>
        /* Ana Tema Stilleri */
        body {
            overflow: hidden;
            background-color: #1a1a1a;
        }
        #scene-container {
            width: 100%;
            height: calc(100vh - 64px); 
        }
        canvas {
            display: block;
        }
        .ui-card {
            background-color: #1F2937; /* Card Arka Planı */
            color: #E5E7EB; /* Açık Gri Font */
            /* Kaydırma sorununu çözmek için kesin yükseklik ve kaydırma ayarı */
            height: calc(100vh - 64px); 
        }
        
        /* Neon Renk Seçici Stilizasyonu */
        .neon-color-button {
            width: 36px;
            height: 36px;
            border: 3px solid transparent;
            transition: transform 0.1s, box-shadow 0.2s;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }
        .neon-color-button.selected {
            border-color: #E5E7EB;
            transform: scale(1.15);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.9);
        }

        /* Radio button stilizasyonu (Boyut Seçici) */
        .size-label {
            @apply w-full block bg-deep-card hover:bg-gray-600 text-white font-semibold py-3 px-4 rounded-xl cursor-pointer transition duration-150 shadow-md border border-deep-card;
        }
        .size-radio:checked + .size-label {
            @apply bg-brand-indigo hover:bg-brand-purple shadow-xl border-2 border-primary-neon;
        }
        
        /* Scrollbar İyileştirmesi */
        #controls {
            scrollbar-width: thin;
            scrollbar-color: #4B5563 #1F2937;
        }
        #controls::-webkit-scrollbar {
            width: 8px;
        }
        #controls::-webkit-scrollbar-thumb {
            background-color: #4B5563;
            border-radius: 10px;
        }
        #controls::-webkit-scrollbar-track {
            background: #1F2937;
        }

        /* Range Input Stilizasyonu (Apple/Google Tarzı Slider) */
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #00F0FF; /* Primary Neon */
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0, 240, 255, 0.8);
            margin-top: -6px; /* İpucu: Chrome için kaydırıcıyı ortala */
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            background: #4B5563; /* Koyu gri iz */
            border-radius: 3px;
            cursor: pointer;
        }
        input[type=range] {
             /* İpucu: Firefox için kaydırıcıyı ortala */
            height: 12px;
            background: transparent;
        }

    </style>
</head>
<body class="font-sans">

    <!-- Ana Konteyner -->
    <div class="h-screen flex flex-col">
        <!-- Başlık ve Kullanıcı Bilgisi (Yüksek Kontrastlı Header) -->
        <header class="bg-dark-bg p-3 shadow-2xl flex justify-between items-center text-white sticky top-0 z-20">
            <div class="flex items-center">
                <img src="https://neonbirr.com/cdn/shop/files/cropped-cropped-Yeni-Proje-24.webp?v=1696324634&width=90" alt="Neon Masa Logo" class="h-8 mr-3 rounded-md shadow-lg">
                <h1 class="text-xl font-extrabold text-primary-neon tracking-wider">MÜKEMMEL NEON MASA KONFİGÜRATÖRÜ</h1>
            </div>
            <div id="user-info" class="text-xs hidden sm:block bg-deep-card/50 px-3 py-1 rounded-full border border-gray-600">
                Kullanıcı ID: <span id="user-id-display" class="font-mono text-yellow-400">Yükleniyor...</span>
            </div>
        </header>

        <!-- Ana İçerik ve Kontroller -->
        <main class="flex-grow flex">
            <!-- Kontrol Paneli (Sol Kenar Çubuğu) -->
            <div id="controls" class="w-1/4 max-w-xs p-4 ui-card overflow-y-auto flex flex-col space-y-6">
                
                <h2 class="text-2xl font-bold border-b pb-2 border-brand-indigo text-white mb-2">Tasarım Akışı</h2>
                
                <!-- 1. Renk Seçimi -->
                <div class="bg-deep-card p-4 rounded-xl shadow-2xl">
                    <label class="block text-xl font-bold mb-3 text-primary-neon border-b border-gray-600 pb-2">1. Rengi Seçin</label>
                    <div id="color-picker" class="flex gap-4 flex-wrap justify-start">
                        <!-- Renk Butonları Buraya JS ile Eklenecek -->
                    </div>
                </div>
                
                <!-- 2. Şekil Kütüphanesi -->
                <div class="space-y-3">
                    <button id="toggle-shapes" class="w-full bg-brand-indigo hover:bg-brand-purple text-white font-bold py-3 px-4 rounded-xl transition duration-150 flex justify-between items-center shadow-lg transform hover:scale-[1.01]">
                        <span class="text-lg">2. Şekil Ekle / Kütüphane</span>
                        <svg id="shapes-arrow" class="w-5 h-5 transform transition-transform duration-300 rotate-0" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                    </button>
                    
                    <!-- Şekil Kütüphanesi İçeriği -->
                    <div id="shape-library" class="hidden p-4 bg-deep-card rounded-xl shadow-xl border border-brand-indigo/50">
                        <button id="add-straight-line" class="w-full bg-primary-neon/80 hover:bg-primary-neon text-gray-900 font-bold py-2 px-4 rounded-lg mb-3 transition duration-150 shadow-lg">
                            Düz Neon Çubuk Ekle (40cm)
                        </button>
                        <div class="grid grid-cols-3 gap-3">
                             <!-- Görsel Şekil Butonları -->
                             <button id="add-zigzag-m-line" class="shape-button flex flex-col items-center justify-center p-3 bg-gray-600 hover:bg-yellow-700/80 rounded-lg transition duration-150 text-yellow-300 shadow-md">
                                <svg class="w-8 h-8" viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="8" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M 10 90 L 35 10 L 60 90 L 85 10 L 90 90" />
                                </svg>
                                <span class="text-xs mt-1">M Şekli</span>
                            </button>
                            <button id="add-zigzag-n-line" class="shape-button flex flex-col items-center justify-center p-3 bg-gray-600 hover:bg-cyan-700/80 rounded-lg transition duration-150 text-cyan-300 shadow-md">
                                <svg class="w-8 h-8" viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="8" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M 10 90 L 10 10 L 90 90 L 90 10" />
                                </svg>
                                <span class="text-xs mt-1">N Harfi</span>
                            </button>
                            <button id="add-v-shape-line" class="shape-button flex flex-col items-center justify-center p-3 bg-gray-600 hover:bg-lime-700/80 rounded-lg transition duration-150 text-lime-300 shadow-md">
                                <svg class="w-8 h-8" viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="8" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M 10 10 L 50 90 L 90 10" />
                                </svg>
                                <span class="text-xs mt-1">V Harfi</span>
                            </button>
                            <button id="add-single-peak-line" class="shape-button flex flex-col items-center justify-center p-3 bg-gray-600 hover:bg-pink-700/80 rounded-lg transition duration-150 text-pink-300 shadow-md">
                                <svg class="w-8 h-8" viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="8" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M 10 90 L 50 10 L 90 90" />
                                </svg>
                                <span class="text-xs mt-1">A Harfi</span>
                            </button>
                        </div>
                    </div>
                </div>

                <!-- 3. Seçili Neon Bilgisi -->
                <div id="selected-element-info" class="bg-deep-card p-4 rounded-xl shadow-2xl border border-teal-500/50 hidden">
                    <p class="font-bold text-xl text-teal-300 mb-3 border-b border-gray-600 pb-2">3. Öğeyi Konumlandır</p>
                    
                    <!-- X Konum Kontrolü (En) -->
                    <div class="mb-4">
                        <label class="block text-sm font-medium mb-2">X Konumunu Ayarla (En)</label>
                        <input type="range" id="control-pos-x" min="-0.4" max="0.4" step="0.01" class="w-full">
                    </div>
                    
                    <!-- Z Konum Kontrolü (Boy) -->
                    <div class="mb-4">
                        <label class="block text-sm font-medium mb-2">Z Konumunu Ayarla (Boy)</label>
                        <input type="range" id="control-pos-z" min="-0.2" max="0.2" step="0.01" class="w-full">
                    </div>

                    <!-- Y Rotasyon Kontrolü -->
                    <div class="mb-4">
                        <label class="block text-sm font-medium mb-2">Y Rotasyonu (Düzlemde)</label>
                        <input type="range" id="control-rot-y" min="0" max="360" step="5" class="w-full">
                    </div>

                    <button id="remove-neon" class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg mt-3 transition duration-150 shadow-md">
                        Seçili Neonu Sil
                    </button>
                </div>

                
                <!-- 4. Ebat ve Fiyatlandırma (Satış Odaklı) -->
                <div class="bg-deep-card p-4 rounded-xl shadow-2xl border-2 border-yellow-500/50 mt-auto">
                    <h2 class="text-xl font-bold mb-3 border-b pb-2 border-gray-600 text-yellow-300">4. Ebat & Fiyatlandırma</h2>
                    
                    <!-- Fiyat Gösterimi -->
                    <div class="bg-gray-800 p-3 rounded-lg mb-4 text-center border border-gray-700">
                        <p class="text-md font-medium text-gray-400">Seçilen Ebat Fiyatı (KDV Dahil):</p>
                        <p id="current-price" class="text-4xl font-extrabold text-yellow-300 my-1">20.000 TL</p>
                        <p class="text-xs mt-1 text-primary-neon font-semibold">Uzaktan Kumanda Tüm Ürünlere DAHİLDİR!</p>
                    </div>

                    <label class="block text-sm font-medium mb-2">Masa Ebatı Seçin (En x Boy x Yükseklik)</label>
                    <div id="size-selector" class="space-y-3">
                        <!-- Boyut Seçenekleri Buraya JS ile Eklenecek -->
                    </div>
                    
                    <!-- Neon/Yazı Sınırları Bilgisi -->
                    <div id="design-limits-info" class="text-xs text-gray-400 p-3 mt-4 rounded bg-gray-800/50 border border-gray-700">
                        <p><strong>Neon Sınırları:</strong> Seçime göre yüklenecektir.</p>
                        <p><strong>Yazı Seçeneği:</strong> 3D tasarıma yazı ekleme özelliği eklenecektir.</p>
                    </div>

                </div>
                
                <!-- 5. Diğer İşlemler (Kaydetme / Cam / Efekt) -->
                <div class="bg-deep-card p-4 rounded-xl shadow-2xl space-y-3">
                    <h2 class="text-xl font-bold mb-3 border-b pb-2 border-gray-600 text-white">5. Araçlar ve Kayıt</h2>
                    
                    <button id="toggle-effect" class="w-full bg-brand-indigo hover:bg-brand-purple text-white font-bold py-2 px-4 rounded-lg transition duration-150 shadow-md">
                        Efektleri Kapat (Neon Kapalı)
                    </button>
                    
                    <button id="toggle-glass" class="w-full bg-orange-500 hover:bg-orange-600 text-white font-bold py-2 px-4 rounded-lg transition duration-150 shadow-md">
                        Camı Kaldır (Tasarım Erişim)
                    </button>
                    
                    <div class="flex space-x-2 pt-2">
                        <button id="save-design" class="w-1/2 bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition duration-150 shadow-md">
                        Kaydet
                        </button>
                        <button id="load-design" class="w-1/2 bg-yellow-500 hover:bg-yellow-600 text-gray-900 font-bold py-2 px-4 rounded-lg transition duration-150 shadow-md">
                            Yükle
                        </button>
                    </div>
                </div>


                <!-- YENİ: WhatsApp Sipariş Butonu (En Altta Sabit ve Göz Alıcı) -->
                <div class="sticky bottom-0 border-t pt-4 border-gray-600">
                    <button id="order-whatsapp" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-4 px-4 rounded-xl text-xl transition duration-150 shadow-2xl flex items-center justify-center transform hover:scale-[1.02]">
                        <svg class="w-6 h-6 mr-2" fill="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12.039 2c-5.584 0-10.126 4.542-10.126 10.126 0 1.748.44 3.421 1.284 4.887l-1.34 4.904 5.025-1.315c1.42 76.54 3.09 1.284 4.837 1.284h.01c5.584 0 10.126-4.542 10.126-10.126s-4.542-10.126-10.126-10.126zm0 18.42c-2.88 0-5.55-.916-7.85-2.52l-.56-.334-3.13.82.83-3.045-.357-.577c-1.64-2.483-2.5-5.32-2.5-8.26 0-4.634 3.766-8.4 8.4-8.4s8.4 3.766 8.4 8.4-3.766 8.4-8.4 8.4zm4.456-6.19c-.244-.122-.962-.477-1.11-.532-.148-.054-.256-.08-.363.08-.107.155-.417.532-.51.64-.093.107-.186.12-.34.037-.154-.08-2.618-1.615-4.997-3.084-.397-.243-.666-.41-2.843-1.745-.246-.145-.353-.2-.407-.225-.053-.027-.42-.032-.816-.032-.397 0-.962.122-1.306.61-.345.488-1.307 1.272-1.307 3.107 0 1.835 1.522 3.593 1.522 3.84 0 .002.396.488.908 1.05.512.56.962.748 1.805.975.842.227 1.73.197 2.37.133.64-.06 1.87-.76 2.14-1.503.268-.743.268-1.373.185-1.503-.082-.13-.148-.155-.303-.236z"/>
                        </svg>
                        SİPARİŞİ TAMAMLA (WhatsApp)
                    </button>
                </div>
            </div>

            <!-- 3D Sahne Konteyneri (Değişmeyen Alan) -->
            <div id="scene-container" class="flex-grow bg-dark-bg relative">
                <div id="loading-overlay" class="absolute inset-0 bg-gray-900/90 flex items-center justify-center z-10 text-white text-xl">
                    3D Sahne Yükleniyor...
                </div>
                <!-- 3D Canvas buraya yerleştirilecek -->
            </div>
        </main>
        
        <!-- Alt Çubuk (Profesyonel İpucu) -->
        <footer class="bg-gray-800 p-2 text-center text-xs text-gray-400">
            İpucu: Masayı döndürmek ve yakınlaştırmak için farenizi kullanın. Seçmek için neon çubuğa tek tıklayın.
        </footer>
    </div>

    <!-- Modallar (UX için zorunlu) -->
    <div id="modal-container" class="hidden fixed inset-0 bg-black bg-opacity-70 z-50 flex items-center justify-center">
        <div class="bg-white p-6 rounded-lg shadow-2xl max-w-sm w-full text-gray-900">
            <h3 id="modal-title" class="text-xl font-bold mb-4">Başlık</h3>
            <p id="modal-message" class="mb-4">Mesaj içeriği.</p>
            <div class="flex justify-end space-x-2">
                <button id="modal-close" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded transition duration-150">
                    Kapat
                </button>
            </div>
        </div>
    </div>

    <script type="module">
        // Global Three.js değişkenleri
        let scene, camera, renderer, controls;
        let db, auth, userId = 'anon_user';
        let neonElementsData = [];
        let selectedNeonObject = null;
        let currentSelectedColor = '#00FFFF'; // Varsayılan: Mavi
        let glassContainer = null; 
        let smokedGlassMirrorMaterial = null; 
        let isEffectOn = true; 
        const NEON_EMISSIVE_POWER_ON = 1.0;
        const NEON_EMISSIVE_POWER_OFF = 0.01; 

        const neonColors = [
            { name: "Mavi", hex: "#00FFFF" },
            { name: "Yeşil", hex: "#00FF00" },
            { name: "Kırmızı", hex: "#FF0000" },
            { name: "Pembe", hex: "#FF00FF" },
            { name: "Sarı", hex: "#FFFF00" },
            { name: "Beyaz", hex: "#FFFFFF" }
        ];

        // Masa Boyutları, Fiyatları ve Sınırları
        const tableSizes = [
            {
                name: "70x45x50 CM (15.000 TL)",
                width: 0.70,
                depth: 0.45,
                height: 0.50,
                price: 15000,
                limits: { m: 1, a: 2, v: 2, n: 2, text_cm: '60cm x 30cm' } 
            },
            {
                name: "90x45x50 CM (20.000 TL)",
                width: 0.90,
                depth: 0.45,
                height: 0.50,
                price: 20000,
                limits: { m: 1, a: 2, v: 2, n: 2, text_cm: '80cm x 30cm' }
            },
            {
                name: "120x80x50 CM (35.000 TL)",
                width: 1.20,
                depth: 0.80,
                height: 0.50,
                price: 35000,
                limits: { m: 2, a: 4, v: 4, n: 4, text_cm: '110cm x 30cm' }
            },
            {
                name: "150x80x50 CM (45.000 TL)",
                width: 1.50,
                depth: 0.80,
                height: 0.50,
                price: 45000,
                limits: { m: 3, a: 6, v: 6, n: 6, text_cm: '140cm x 30cm' }
            }
        ];

        // Sabitler (Mevcut seçime göre dinamik olacak)
        let currentSizeIndex = 1; 
        let TABLE_WIDTH = tableSizes[currentSizeIndex].width; 
        let TABLE_DEPTH = tableSizes[currentSizeIndex].depth; 
        let TABLE_FRAME_HEIGHT = tableSizes[currentSizeIndex].height; 
        
        // Three.js geometrik sabitleri
        const BASE_THICKNESS = 0.05; 
        let WORKING_PLANE_HEIGHT = TABLE_FRAME_HEIGHT - BASE_THICKNESS; 
        const BASE_Y = 0; 
        const WORKING_PLANE_Y = BASE_Y + BASE_THICKNESS + 0.01; 
        const MAX_NEON_HEIGHT = 0.40; 

        const NEON_RADIUS = 0.008; 
        const glassThickness = 0.02; 


        // --- Firebase ve Auth İşlemleri ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        /** Modalı gösterir */
        function showModal(title, message) {
            document.getElementById('modal-title').textContent = title;
            document.getElementById('modal-message').textContent = message;
            document.getElementById('modal-container').classList.remove('hidden');
        }

        /** Firebase'i başlatır ve kullanıcıyı oturum açar */
        async function initializeFirebase() {
            if (Object.keys(firebaseConfig).length === 0) {
                console.error("Firebase config is missing. Using anonymous setup.");
                document.getElementById('user-id-display').textContent = 'Anonim (Kaydetme Devre Dışı)';
                initThreeJS(); 
                return;
            }

            try {
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                setLogLevel('Debug'); 

                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }

                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        document.getElementById('user-id-display').textContent = userId;
                        initThreeJS(); 
                    } else {
                        userId = crypto.randomUUID();
                        document.getElementById('user-id-display').textContent = `Anonim ID: ${userId.substring(0, 8)}...`;
                        initThreeJS();
                    }
                });

            } catch (error) {
                console.error("Firebase başlatma hatası:", error);
                showModal("Hata", "Firebase başlatılamadı. Tasarım kaydetme çalışmayabilir.");
                initThreeJS(); 
            }
        }

        // --- Three.js Sahne ve Nesne Oluşturma ---

        function initThreeJS() {
            // Boyutları güncelle
            const currentSize = tableSizes[currentSizeIndex];
            TABLE_WIDTH = currentSize.width;
            TABLE_DEPTH = currentSize.depth;
            TABLE_FRAME_HEIGHT = currentSize.height;
            WORKING_PLANE_HEIGHT = TABLE_FRAME_HEIGHT - BASE_THICKNESS;
            
            document.getElementById('loading-overlay').classList.add('hidden');
            const container = document.getElementById('scene-container');
            
            if (scene) {
                const oldCanvas = renderer?.domElement;
                if (oldCanvas) {
                    container.removeChild(oldCanvas);
                }
            }

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111); 

            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(TABLE_WIDTH * 2, TABLE_FRAME_HEIGHT * 2, TABLE_DEPTH * 2); 

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            container.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.minDistance = 1;
            controls.maxDistance = 5;
            controls.target.set(0, TABLE_FRAME_HEIGHT / 2, 0); 
            controls.update();

            scene.add(new THREE.AmbientLight(0x404040, 5)); 
            
            createTable();
            
            if (!document.getElementById('size-selector').children.length) {
                setupUI();
            }

            loadUserDesign(userId);
            
            animate();

            window.removeEventListener('resize', onWindowResize); 
            window.addEventListener('resize', onWindowResize, false);

            renderer.domElement.removeEventListener('click', onCanvasClick); 
            renderer.domElement.addEventListener('click', onCanvasClick, false);
        }

        function onWindowResize() {
            const container = document.getElementById('scene-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        function createTable() {
            const tableGroup = new THREE.Group();
            tableGroup.name = "Neon_Table_Group";

            const baseGeometry = new THREE.BoxGeometry(TABLE_WIDTH + 0.05, BASE_THICKNESS, TABLE_DEPTH + 0.05);
            const baseMaterial = new THREE.MeshStandardMaterial({
                color: 0x000000, 
                metalness: 0.1,
                roughness: 0.8, 
            });
            const baseMesh = new THREE.Mesh(baseGeometry, baseMaterial);
            baseMesh.position.y = BASE_Y + BASE_THICKNESS / 2;
            tableGroup.add(baseMesh);

            const innerBaseGeometry = new THREE.BoxGeometry(TABLE_WIDTH, 0.005, TABLE_DEPTH);
            const innerBaseMaterial = new THREE.MeshStandardMaterial({
                color: 0x000000,
                metalness: 0.95,
                roughness: 0.0, 
            });
            const innerBaseMesh = new THREE.Mesh(innerBaseGeometry, innerBaseMaterial);
            innerBaseMesh.position.y = WORKING_PLANE_Y; 
            innerBaseMesh.userData.isWorkingPlane = true;
            tableGroup.add(innerBaseMesh);

            smokedGlassMirrorMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x222222, 
                metalness: 0.8, 
                roughness: 0.1, 
                opacity: 0.1, 
                transparent: true,
                transmission: 0.0, 
                reflectivity: 0.95, 
                clearcoat: 1.0,
                clearcoatRoughness: 0.1,
                side: THREE.DoubleSide 
            });

            glassContainer = new THREE.Group();
            glassContainer.name = 'GlassContainer';
            const wallHeight = WORKING_PLANE_HEIGHT;
            const center_Y = BASE_THICKNESS + wallHeight / 2;
            
            glassContainer.userData.closedPosition = new THREE.Vector3(0, BASE_THICKNESS, 0); 
            glassContainer.userData.openPosition = new THREE.Vector3(TABLE_WIDTH * 1.5, BASE_THICKNESS, 0);


            const side1 = new THREE.Mesh(new THREE.BoxGeometry(TABLE_WIDTH, wallHeight, glassThickness), smokedGlassMirrorMaterial);
            side1.position.set(0, center_Y - BASE_THICKNESS, TABLE_DEPTH / 2 + glassThickness / 2);
            glassContainer.add(side1);
            
            const side2 = new THREE.Mesh(new THREE.BoxGeometry(TABLE_WIDTH, wallHeight, glassThickness), smokedGlassMirrorMaterial);
            side2.position.set(0, center_Y - BASE_THICKNESS, -TABLE_DEPTH / 2 - glassThickness / 2);
            glassContainer.add(side2);

            const side3 = new THREE.Mesh(new THREE.BoxGeometry(glassThickness, wallHeight, TABLE_DEPTH + 2 * glassThickness), smokedGlassMirrorMaterial);
            side3.position.set(TABLE_WIDTH / 2 + glassThickness / 2, center_Y - BASE_THICKNESS, 0);
            glassContainer.add(side3);

            const side4 = new THREE.Mesh(new THREE.BoxGeometry(glassThickness, wallHeight, TABLE_DEPTH + 2 * glassThickness), smokedGlassMirrorMaterial);
            side4.position.set(-TABLE_WIDTH / 2 - glassThickness / 2, center_Y - BASE_THICKNESS, 0);
            glassContainer.add(side4);


            const glassMesh = new THREE.Mesh(new THREE.BoxGeometry(TABLE_WIDTH + 2 * glassThickness, glassThickness, TABLE_DEPTH + 2 * glassThickness), smokedGlassMirrorMaterial);
            
            const capY = WORKING_PLANE_HEIGHT + glassThickness / 2;
            glassMesh.position.y = capY - BASE_THICKNESS; 
            glassMesh.userData.isGlass = true;
            glassMesh.userData.name = 'Glass_Cover';
            glassContainer.add(glassMesh);
            
            glassContainer.position.copy(glassContainer.userData.closedPosition); 
            tableGroup.add(glassContainer);

            scene.add(tableGroup);

            const neonContainer = new THREE.Group();
            neonContainer.name = 'NeonContainer';
            neonContainer.position.y = WORKING_PLANE_Y; 
            scene.add(neonContainer);
        }
        
        function toggleEffect() {
            isEffectOn = !isEffectOn;
            const neonContainer = scene.getObjectByName('NeonContainer');
            const toggleButton = document.getElementById('toggle-effect');

            const newEmissivePower = isEffectOn ? NEON_EMISSIVE_POWER_ON : NEON_EMISSIVE_POWER_OFF;
            const newReflectivity = isEffectOn ? 0.95 : 0.01; 
            
            if (neonContainer) {
                neonContainer.children.forEach(mesh => {
                    if (mesh.userData.isNeon && mesh.material) {
                        mesh.material.emissiveIntensity = newEmissivePower;
                        mesh.material.needsUpdate = true; 
                    }
                });
            }
            
            if (smokedGlassMirrorMaterial) {
                smokedGlassMirrorMaterial.reflectivity = newReflectivity;
                smokedGlassMirrorMaterial.needsUpdate = true;
            }

            if (isEffectOn) {
                toggleButton.textContent = "Efektleri Kapat (Neon Kapalı)";
                toggleButton.classList.remove('bg-gray-500', 'hover:bg-gray-600');
                toggleButton.classList.add('bg-brand-indigo', 'hover:bg-brand-purple');
            } else {
                toggleButton.textContent = "Efektleri Aç (Neon Açık)";
                toggleButton.classList.remove('bg-brand-indigo', 'hover:bg-brand-purple');
                toggleButton.classList.add('bg-gray-500', 'hover:bg-gray-600');
            }
        }


        function createNeonObject(color, type) {
            const hexColor = new THREE.Color(color);
            const emissivePower = isEffectOn ? NEON_EMISSIVE_POWER_ON : NEON_EMISSIVE_POWER_OFF;
            
            const emissiveMaterial = new THREE.MeshBasicMaterial({
                color: hexColor,
                emissive: hexColor,
                emissiveIntensity: emissivePower,
                side: THREE.DoubleSide
            });

            let geometry;
            let length;

            if (type === 'straight') {
                length = MAX_NEON_HEIGHT; 
                geometry = new THREE.CylinderGeometry(NEON_RADIUS, NEON_RADIUS, length, 16);
            } 
            else if (type === 'zigzag_m') {
                length = MAX_NEON_HEIGHT * 0.9; 
                const width = TABLE_WIDTH * 0.35; 
                
                const points = [
                    new THREE.Vector3(-width / 2, -length / 2, 0), 
                    new THREE.Vector3(-width / 4, length / 2, 0),             
                    new THREE.Vector3(0, -length / 2 + 0.05, 0), 
                    new THREE.Vector3(width / 4, length / 2, 0),
                    new THREE.Vector3(width / 2, -length / 2, 0) 
                ];

                const customCurve = new THREE.CatmullRomCurve3(points);
                customCurve.curveType = 'chordal'; 
                geometry = new THREE.TubeGeometry(customCurve, 64, NEON_RADIUS, 8, false); 
            }
            else if (type === 'zigzag_n') {
                length = MAX_NEON_HEIGHT * 0.9; 
                const width = TABLE_WIDTH * 0.35;

                const points = [
                    new THREE.Vector3(-width / 2, -length / 2, 0), 
                    new THREE.Vector3(-width / 2, length / 2, 0),             
                    new THREE.Vector3(width / 2, -length / 2 + 0.05, 0), 
                    new THREE.Vector3(width / 2, length / 2, 0)
                ];

                const customCurve = new THREE.CatmullRomCurve3(points);
                customCurve.curveType = 'chordal'; 
                geometry = new THREE.TubeGeometry(customCurve, 64, NEON_RADIUS, 8, false); 
            }
            else if (type === 'v_shape') {
                length = MAX_NEON_HEIGHT * 0.7;
                const width = TABLE_WIDTH * 0.3;

                const points = [
                    new THREE.Vector3(-width / 2, length / 2, 0), 
                    new THREE.Vector3(0, -length / 2 + 0.05, 0), 
                    new THREE.Vector3(width / 2, length / 2, 0) 
                ];

                const customCurve = new THREE.CatmullRomCurve3(points);
                customCurve.curveType = 'chordal'; 
                geometry = new THREE.TubeGeometry(customCurve, 32, NEON_RADIUS, 8, false); 
            }
            else if (type === 'single_peak') {
                length = MAX_NEON_HEIGHT * 0.9;
                const width = TABLE_WIDTH * 0.3;

                const points = [
                    new THREE.Vector3(-width / 2, -length / 2, 0), 
                    new THREE.Vector3(0, length / 2, 0), 
                    new THREE.Vector3(width / 2, -length / 2, 0)
                ];

                const customCurve = new THREE.CatmullRomCurve3(points);
                customCurve.curveType = 'chordal'; 
                geometry = new THREE.TubeGeometry(customCurve, 32, NEON_RADIUS, 8, false); 
            }
            else {
                return null;
            }

            const neonMesh = new THREE.Mesh(geometry, emissiveMaterial);
            neonMesh.userData.isNeon = true;
            neonMesh.userData.color = color;
            neonMesh.userData.type = type;
            neonMesh.userData.length = length;
            neonMesh.userData.id = THREE.MathUtils.generateUUID();
            
            const halfWidth = TABLE_WIDTH / 2 - NEON_RADIUS;
            const halfDepth = TABLE_DEPTH / 2 - NEON_RADIUS;

            neonMesh.position.set(
                THREE.MathUtils.clamp((Math.random() - 0.5) * TABLE_WIDTH * 0.5, -halfWidth, halfWidth),
                length / 2, 
                THREE.MathUtils.clamp((Math.random() - 0.5) * TABLE_DEPTH * 0.5, -halfDepth, halfDepth)
            );
            neonMesh.rotation.y = Math.random() * Math.PI * 2; 

            neonElementsData.push({
                id: neonMesh.userData.id,
                color: neonMesh.userData.color,
                type: neonMesh.userData.type,
                position: neonMesh.position.toArray(), 
                rotation: neonMesh.rotation.toArray()
            });

            scene.getObjectByName('NeonContainer').add(neonMesh);
            return neonMesh;
        }

        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();

        function onCanvasClick(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            
            const neonContainer = scene.getObjectByName('NeonContainer');
            if (!neonContainer) return;
            
            const intersects = raycaster.intersectObjects(neonContainer.children, false);

            if (intersects.length > 0) {
                const neonMesh = intersects[0].object;
                if (neonMesh.userData.isNeon) {
                    selectNeon(neonMesh);
                }
            } else {
                selectNeon(null); 
            }
        }
        
        function selectNeon(mesh) {
            if (selectedNeonObject) {
            }

            selectedNeonObject = mesh;
            const infoPanel = document.getElementById('selected-element-info');
            
            if (mesh) {
                controls.target.copy(mesh.getWorldPosition(new THREE.Vector3()));
                controls.update();
                
                infoPanel.classList.remove('hidden');
                
                const data = neonElementsData.find(d => d.id === mesh.userData.id);
                if (data) {
                    document.getElementById('control-pos-x').value = data.position[0];
                    document.getElementById('control-pos-z').value = data.position[2];
                    const rotationYDeg = (data.rotation[1] * 180 / Math.PI) % 360;
                    document.getElementById('control-rot-y').value = rotationYDeg < 0 ? rotationYDeg + 360 : rotationYDeg;
                }
            } else {
                infoPanel.classList.add('hidden');
                controls.target.set(0, TABLE_FRAME_HEIGHT / 2, 0);
                controls.update();
            }
        }

        function setupUI() {
            // Renk Seçimi UI
            const colorPicker = document.getElementById('color-picker');
            neonColors.forEach(c => {
                const button = document.createElement('button');
                button.className = 'neon-color-button rounded-full transition duration-150 shadow-lg';
                button.style.backgroundColor = c.hex;
                button.title = c.name;
                button.dataset.color = c.hex;
                button.addEventListener('click', () => {
                    currentSelectedColor = c.hex;
                    document.querySelectorAll('.neon-color-button').forEach(btn => btn.classList.remove('selected'));
                    button.classList.add('selected');

                    if (selectedNeonObject) {
                        updateNeonColor(selectedNeonObject, c.hex);
                        saveDesignDebounced();
                    }
                });
                colorPicker.appendChild(button);
                if (c.hex === currentSelectedColor) {
                    button.classList.add('selected');
                }
            });
            
            document.getElementById('toggle-effect').addEventListener('click', toggleEffect);

            // Şekil Kütüphanesi Aç/Kapa
            const toggleShapesButton = document.getElementById('toggle-shapes');
            const shapeLibrary = document.getElementById('shape-library');
            const shapesArrow = document.getElementById('shapes-arrow');

            toggleShapesButton.addEventListener('click', () => {
                const isHidden = shapeLibrary.classList.toggle('hidden');
                shapesArrow.classList.toggle('rotate-180', !isHidden);
            });
            
            // Şekil Kütüphanesi Ekleme Butonları
            document.getElementById('add-straight-line').addEventListener('click', () => {
                const neon = createNeonObject(currentSelectedColor, 'straight');
                selectNeon(neon);
                saveDesignDebounced();
            });
            document.getElementById('add-zigzag-m-line').addEventListener('click', () => {
                const neon = createNeonObject(currentSelectedColor, 'zigzag_m');
                selectNeon(neon);
                saveDesignDebounced();
            });
            document.getElementById('add-zigzag-n-line').addEventListener('click', () => {
                const neon = createNeonObject(currentSelectedColor, 'zigzag_n');
                selectNeon(neon);
                saveDesignDebounced();
            });
            document.getElementById('add-v-shape-line').addEventListener('click', () => {
                const neon = createNeonObject(currentSelectedColor, 'v_shape');
                selectNeon(neon);
                saveDesignDebounced();
            });
            document.getElementById('add-single-peak-line').addEventListener('click', () => {
                const neon = createNeonObject(currentSelectedColor, 'single_peak');
                selectNeon(neon);
                saveDesignDebounced();
            });

            // Seçili Neon Kontrolleri
            document.getElementById('control-pos-x').addEventListener('input', (e) => {
                if (selectedNeonObject) {
                    selectedNeonObject.position.x = parseFloat(e.target.value);
                    updateNeonData(selectedNeonObject);
                    saveDesignDebounced();
                }
            });
            
            document.getElementById('control-pos-z').addEventListener('input', (e) => {
                if (selectedNeonObject) {
                    selectedNeonObject.position.z = parseFloat(e.target.value);
                    updateNeonData(selectedNeonObject);
                    saveDesignDebounced();
                }
            });
            
            document.getElementById('control-rot-y').addEventListener('input', (e) => {
                if (selectedNeonObject) {
                    selectedNeonObject.rotation.y = parseFloat(e.target.value) * Math.PI / 180;
                    updateNeonData(selectedNeonObject);
                    saveDesignDebounced();
                }
            });
            
            document.getElementById('remove-neon').addEventListener('click', () => {
                if (selectedNeonObject) {
                    removeNeonObject(selectedNeonObject);
                    selectNeon(null);
                    saveDesignDebounced();
                }
            });
            document.getElementById('modal-close').addEventListener('click', () => {
                document.getElementById('modal-container').classList.add('hidden');
            });
            
            // Boyut Seçimi UI
            const sizeSelector = document.getElementById('size-selector');
            const currentPriceDisplay = document.getElementById('current-price');
            const limitsInfo = document.getElementById('design-limits-info');
            
            function updateSizeDisplay() {
                const currentSize = tableSizes[currentSizeIndex];
                currentPriceDisplay.textContent = `${currentSize.price.toLocaleString('tr-TR')} TL`;
                limitsInfo.innerHTML = `
                    <p><strong>Neon Sınırları (Harf/Şekil):</strong> M: ${currentSize.limits.m}, A: ${currentSize.limits.a}, V: ${currentSize.limits.v}, N: ${currentSize.limits.n} (Toplam sınır)</p>
                    <p><strong>Veya Yazı Ekleme:</strong> Yaklaşık ${currentSize.limits.text_cm} alan kullanılabilir (Yazı seçilirse şekil eklenemez).</p>
                `;
            }

            tableSizes.forEach((size, index) => {
                const radio = document.createElement('input');
                radio.type = 'radio';
                radio.name = 'table-size';
                radio.id = `size-${index}`;
                radio.value = index;
                radio.checked = index === currentSizeIndex;
                radio.className = 'hidden size-radio peer';

                const label = document.createElement('label');
                label.htmlFor = `size-${index}`;
                label.className = 'size-label';
                label.textContent = size.name;

                radio.addEventListener('change', () => {
                    if (currentSizeIndex === index) return;
                    
                    currentSizeIndex = index;
                    
                    const neonContainer = scene.getObjectByName('NeonContainer');
                    if (neonContainer) {
                        neonContainer.children.slice().forEach(child => {
                            if (child.userData.isNeon) {
                                child.geometry.dispose();
                                child.material.dispose();
                                neonContainer.remove(child);
                            }
                        });
                    }
                    neonElementsData = []; 
                    
                    updateSizeDisplay();
                    
                    initThreeJS(); 
                    showModal("Boyut Değişikliği", `${size.name} ebatına geçildi. Tasarımınız sıfırlandı. Lütfen yeni ebatta tekrar tasarlayın.`);
                });

                sizeSelector.appendChild(radio);
                sizeSelector.appendChild(label);
            });
            
            updateSizeDisplay();

            // Cam Aç/Kapa butonu
            document.getElementById('toggle-glass').addEventListener('click', () => {
                if (!glassContainer) return; 

                const closedPos = glassContainer.userData.closedPosition;
                const openPos = new THREE.Vector3(TABLE_WIDTH * 1.5, BASE_THICKNESS, 0);
                
                const isClosed = glassContainer.position.distanceTo(closedPos) < 0.01;

                if (isClosed) { 
                    glassContainer.position.copy(openPos); 
                    document.getElementById('toggle-glass').textContent = "Camı Kapat";
                } else { 
                    glassContainer.position.copy(closedPos); 
                    document.getElementById('toggle-glass').textContent = "Camı Kaldır (Tasarım Erişim)";
                }
            });


            // WhatsApp Sipariş Butonu
            document.getElementById('order-whatsapp').addEventListener('click', () => {
                const currentSize = tableSizes[currentSizeIndex];
                const selectedSize = currentSize.name;
                const totalPrice = currentSize.price;
                
                const designDetails = JSON.stringify(neonElementsData.map(d => ({
                    type: d.type,
                    color: d.color,
                    position_x: d.position[0].toFixed(2),
                    position_z: d.position[2].toFixed(2),
                    rotation_y: (d.rotation[1] * 180 / Math.PI).toFixed(0) + ' derece'
                })), null, 2);
                
                const message = `Merhaba, Neon Masa Tasarımım ile ilgili sipariş vermek istiyorum.

* **Seçilen Ebat:** ${selectedSize}
* **Ebat Fiyatı:** ${totalPrice.toLocaleString('tr-TR')} TL
* **Uzaktan Kumanda:** Dahil
* **Tasarım Detayları:**
${designDetails}

Lütfen en kısa zamanda benimle iletişime geçin. (Tasarım ID: ${userId})`;

                const phoneNumber = '905551234567'; 
                
                const whatsappUrl = `https://wa.me/${phoneNumber}?text=${encodeURIComponent(message)}`;
                window.open(whatsappUrl, '_blank');
            });
        }
        
        function updateNeonData(mesh) {
            if (!mesh.userData.isNeon) return;

            const halfWidth = TABLE_WIDTH / 2 - NEON_RADIUS;
            const halfDepth = TABLE_DEPTH / 2 - NEON_RADIUS;
            
            mesh.position.x = THREE.MathUtils.clamp(mesh.position.x, -halfWidth, halfWidth);
            mesh.position.z = THREE.MathUtils.clamp(mesh.position.z, -halfDepth, halfDepth);
            
             const data = neonElementsData.find(d => d.id === mesh.userData.id);
             if (data) {
                data.position = mesh.position.toArray();
                data.rotation = mesh.rotation.toArray();
             }
        }

        function updateNeonColor(mesh, color) {
            if (!mesh || !mesh.material) {
                console.error("updateNeonColor: Mesh veya materyal tanımsız. Renk güncellenemedi.");
                return;
            }
            
            const hexColor = new THREE.Color(color);
            mesh.material.color.set(hexColor);
            mesh.material.emissive.set(hexColor);
            
            mesh.material.emissiveIntensity = isEffectOn ? NEON_EMISSIVE_POWER_ON : NEON_EMISSIVE_POWER_OFF;
            mesh.userData.color = color;

             const data = neonElementsData.find(d => d.id === mesh.userData.id);
             if (data) {
                data.color = color;
             }
        }

        function removeNeonObject(mesh) {
            const neonContainer = scene.getObjectByName('NeonContainer');
            if (neonContainer) {
                neonContainer.remove(mesh);
            }
            neonElementsData = neonElementsData.filter(d => d.id !== mesh.userData.id);
            mesh.geometry.dispose();
            mesh.material.dispose();
        }

        const designDocRef = () => {
            return doc(
                db,
                'artifacts',
                appId,
                'users',
                userId,
                'designs', 
                'neon_table_design' 
            );
        };

        const DEBOUNCE_DELAY = 1000; 
        let saveTimeout = null;

        function saveDesignDebounced() {
            clearTimeout(saveTimeout);
            saveTimeout = setTimeout(() => {
                saveUserDesign();
            }, DEBOUNCE_DELAY);
        }

        async function saveUserDesign() {
            if (!db || !userId || userId === 'anon_user') {
                console.warn("Kullanıcı kimliği veya Firebase hazır değil. Kaydetme işlemi iptal edildi.");
                return;
            }
            
            const savePayload = {
                version: 2, 
                lastUpdated: Date.now(),
                selectedSizeIndex: currentSizeIndex, 
                neonElements: JSON.stringify(neonElementsData) 
            };

            try {
                await setDoc(designDocRef(), savePayload);
                console.log("Tasarım başarıyla kaydedildi!");
            } catch (error) {
                console.error("Tasarım kaydetme hatası:", error);
                showModal("Kaydetme Hatası", "Tasarım kaydedilirken bir sorun oluştu.");
            }
        }

        async function loadUserDesign() {
            if (!db || !userId) {
                 console.warn("Kullanıcı kimliği veya Firebase hazır değil. Yükleme iptal edildi.");
                return;
            }
            
            const loadButton = document.getElementById('load-design');
            loadButton.textContent = 'Yükleniyor...';
            loadButton.disabled = true;

            try {
                const docSnap = await getDoc(designDocRef());

                if (docSnap.exists()) {
                    const data = docSnap.data();
                    
                    const loadedSizeIndex = data.selectedSizeIndex !== undefined ? data.selectedSizeIndex : 1;
                    
                    if (loadedSizeIndex !== currentSizeIndex) {
                        currentSizeIndex = loadedSizeIndex;
                        document.getElementById(`size-${currentSizeIndex}`).checked = true;
                        
                        const currentSize = tableSizes[currentSizeIndex];
                        TABLE_WIDTH = currentSize.width;
                        TABLE_DEPTH = currentSize.depth;
                        TABLE_FRAME_HEIGHT = currentSize.height;
                        WORKING_PLANE_HEIGHT = TABLE_FRAME_HEIGHT - BASE_THICKNESS;
                        
                        const neonContainer = scene.getObjectByName('NeonContainer');
                        if (neonContainer) {
                            neonContainer.children.slice().forEach(child => {
                                child.geometry.dispose();
                                child.material.dispose();
                                neonContainer.remove(child);
                            });
                        }
                        
                        camera.position.set(TABLE_WIDTH * 2, TABLE_FRAME_HEIGHT * 2, TABLE_DEPTH * 2);
                        controls.target.set(0, TABLE_FRAME_HEIGHT / 2, 0); 
                        controls.update();

                        createTable(); 
                        
                        document.getElementById('current-price').textContent = `${currentSize.price.toLocaleString('tr-TR')} TL`;
                        document.getElementById('design-limits-info').innerHTML = `
                            <p><strong>Neon Sınırları (Harf/Şekil):</strong> M: ${currentSize.limits.m}, A: ${currentSize.limits.a}, V: ${currentSize.limits.v}, N: ${currentSize.limits.n} (Toplam sınır)</p>
                            <p><strong>Veya Yazı Ekleme:</strong> Yaklaşık ${currentSize.limits.text_cm} alan kullanılabilir (Yazı seçilirse şekil eklenemez).</p>
                        `;

                    }


                    if (data.neonElements) {
                        const loadedData = JSON.parse(data.neonElements);
                        
                        const neonContainer = scene.getObjectByName('NeonContainer');
                        if (neonContainer) {
                            neonContainer.children.forEach(child => {
                                if (child.userData.isNeon) {
                                    child.geometry.dispose();
                                    child.material.dispose();
                                    neonContainer.remove(child);
                                }
                            });
                        }
                        neonElementsData = [];

                        loadedData.forEach(data => {
                            const mesh = createNeonObject(data.color, data.type);
                            mesh.position.fromArray(data.position);
                            mesh.rotation.fromArray(data.rotation);
                            updateNeonData(mesh); 
                        });

                        showModal("Yükleme Başarılı", `Kaydedilmiş ${loadedData.length} adet neon öğesi yüklendi.`);
                    }
                } else {
                    console.log("Kayıtlı bir tasarım bulunamadı.");
                    showModal("Bilgi", "Kayıtlı bir tasarım bulunamadı. Yeni bir tasarımla başlayın.");
                }
            } catch (error) {
                console.error("Tasarım yükleme hatası:", error);
                showModal("Yükleme Hatası", "Tasarım yüklenirken bir sorun oluştu.");
            } finally {
                loadButton.textContent = 'Yükle';
                loadButton.disabled = false;
